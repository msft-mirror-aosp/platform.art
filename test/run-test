#!/usr/bin/env python3
#
# Copyright (C) 2007 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os, sys, glob, re, shutil, subprocess, shlex, resource, atexit

import default_run as default_run_module

from argparse import ArgumentParser, BooleanOptionalAction
from default_run import get_target_arch
from importlib.machinery import SourceFileLoader
from inspect import currentframe, getframeinfo, FrameInfo
from pathlib import Path
from shutil import copyfile
from testrunner import env
from typing import Optional, Dict, List
from zipfile import ZipFile

COLOR = (os.environ.get("LUCI_CONTEXT") == None)  # Disable colors on LUCI.
COLOR_BLUE = '\033[94m' if COLOR else ''
COLOR_GREEN = '\033[92m' if COLOR else ''
COLOR_NORMAL = '\033[0m' if COLOR else ''
COLOR_RED = '\033[91m' if COLOR else ''

# Helper class which allows us to access the environment using syntax sugar.
# E.g. `env.ANDROID_BUILD_TOP` instead of `os.environ["ANDROID_BUILD_TOP"]`.
class Environment:

  def __getattr__(self, name):
    return os.environ.get(name)

  def __setattr__(self, name, value):
    os.environ[name] = str(value)


# Context passed to individual tests to let them customize the behaviour.
class RunTestContext:

  def __init__(self, tmp_dir: Path, target: bool, chroot, dex_location, test_name) -> None:
    self.env = Environment()
    self.target = target
    self.chroot = chroot
    self.dex_location = dex_location
    self.test_name = test_name

    # Note: The expected path can be modified by the tests.
    self.expected_stdout = tmp_dir / "expected-stdout.txt"
    self.expected_stderr = tmp_dir / "expected-stderr.txt"

    self.runner: List[str] = ["#!/bin/bash"]

  def echo(self, text):
    self.run(f"echo {text} > {test_stdout}")

  def export(self, **env: str) -> None:
    self.runner.append("")
    for name, value in env.items():
      self.runner.append(f"export {name}={value}")

  # Add "runner" script command. It is not executed now.
  # All "runner" commands are executed later via single bash call.
  def run(self, cmd: str, check: bool=True, expected_exit_code: int=0, desc:str = None) -> None:
    if cmd == "true":
      return
    cmd_esc = cmd.replace("'", r"'\''")
    self.runner.append("")
    self.runner.append(f"echo '{COLOR_BLUE}$$ {cmd_esc}{COLOR_NORMAL}'")
    self.runner.append(cmd)

    # Check the exit code.
    if check:
      caller = getframeinfo(currentframe().f_back)  # type: ignore
      source = "{}:{}".format(Path(caller.filename).name, caller.lineno)
      msg = f"{self.test_name} FAILED: [{source}] "
      msg += "{} returned exit code ${{exit_code}}.".format(desc or "Command")
      if expected_exit_code:
        msg += f" Expected {expected_exit_code}."
      self.runner.append(
        f"exit_code=$?; if [ $exit_code -ne {expected_exit_code} ]; then "
        f"echo {COLOR_RED}{msg}{COLOR_NORMAL}; exit 100; "
        f"fi; ")
    else:
      self.runner.append("true; # Ignore previous exit code")

  # Execute the default runner (possibly with modified arguments).
  def default_run(self, args, **kwargs):
    default_run_module.default_run(self, args, **kwargs)


# TODO: Replace with 'def main():' (which might change variables from globals to locals)
if True:
  progdir = os.path.dirname(__file__)
  oldwd = os.getcwd()
  os.chdir(progdir)
  test_dir = "test-{}".format(os.getpid())
  TMPDIR = os.environ.get("TMPDIR")
  USER = os.environ.get("USER")
  PYTHON3 = os.environ.get("PYTHON3")
  if not TMPDIR:
    tmp_dir = f"/tmp/{USER}/{test_dir}"
  else:
    tmp_dir = f"{TMPDIR}/{test_dir}"
  checker = f"{progdir}/../tools/checker/checker.py"

  ON_VM = env.ART_TEST_ON_VM
  SSH_USER = env.ART_TEST_SSH_USER
  SSH_HOST = env.ART_TEST_SSH_HOST
  SSH_PORT = env.ART_TEST_SSH_PORT
  SSH_CMD = env.ART_SSH_CMD
  SCP_CMD = env.ART_SCP_CMD
  CHROOT = env.ART_TEST_CHROOT
  CHROOT_CMD = env.ART_CHROOT_CMD

  def fail(message: str, caller:Optional[FrameInfo]=None):
    caller = caller or getframeinfo(currentframe().f_back)  # type: ignore
    assert caller
    source = "{}:{}".format(Path(caller.filename).name, caller.lineno)
    print(f"{COLOR_RED}{TEST_NAME} FAILED: [{source}] {message}{COLOR_NORMAL}",
          file=sys.stderr)
    sys.exit(1)

  def run(cmdline: str, check=True, fail_message=None) -> subprocess.CompletedProcess:
    print(f"{COLOR_BLUE}$ {cmdline}{COLOR_NORMAL}", flush=True)
    proc = subprocess.run([cmdline],
                          shell=True,
                          executable="/bin/bash",
                          stderr=subprocess.STDOUT)
    if (check and proc.returncode != 0):
      if fail_message:
        # If we have custom fail message, exit without printing the full backtrace.
        fail(fail_message, getframeinfo(currentframe().f_back))  # type: ignore
      raise Exception(f"Command failed (exit code {proc.returncode})")
    return proc

  def export(env: str, value: str) -> None:
    os.environ[env] = value
    globals()[env] = value

  def error(msg) -> None:
    print(msg, file=sys.stderr, flush=True)

  # ANDROID_BUILD_TOP is not set in a build environment.
  ANDROID_BUILD_TOP = os.environ.get("ANDROID_BUILD_TOP")
  if not ANDROID_BUILD_TOP:
    export("ANDROID_BUILD_TOP", oldwd)

  export("JAVA", "java")
  export("JAVAC", "javac -g -Xlint:-options -source 1.8 -target 1.8")
  export("PYTHON3",
         f"{ANDROID_BUILD_TOP}/prebuilts/build-tools/path/linux-x86/python3")
  export("RUN", f"{PYTHON3} {progdir}/etc/run-test-jar")
  export("DEX_LOCATION", f"/data/run-test/{test_dir}")

  # OUT_DIR defaults to out, and may be relative to ANDROID_BUILD_TOP.
  # Convert it to an absolute path, since we cd into the tmp_dir to run the tests.
  OUT_DIR = os.environ.get("OUT_DIR", "")
  export("OUT_DIR", OUT_DIR or "out")
  if not OUT_DIR.startswith("/"):
    export("OUT_DIR", f"{ANDROID_BUILD_TOP}/{OUT_DIR}")

# ANDROID_HOST_OUT is not set in a build environment.
  ANDROID_HOST_OUT = os.environ.get("ANDROID_HOST_OUT")
  if not ANDROID_HOST_OUT:
    export("ANDROID_HOST_OUT", f"{OUT_DIR}/host/linux-x86")

  host_lib_root = ANDROID_HOST_OUT
  chroot = ""
  info = "info.txt"
  run_cmd = "run"
  test_stdout = "test-stdout.txt"
  test_stderr = "test-stderr.txt"
  cfg_output = "graph.cfg"
  strace_output = "strace-output.txt"
  lib = "libartd.so"
  testlib = "arttestd"
  run_args = []
  run_checker = "no"

  quiet = "no"
  debuggable = "no"
  prebuild_mode = "yes"
  target_mode = "yes"
  dev_mode = "no"
  create_runner = "no"
  update_mode = "no"
  debug_mode = "no"
  relocate = "no"
  runtime = "art"
  usage = "no"
  suffix64 = ""
  trace = "false"
  trace_stream = "false"
  basic_verify = "false"
  gc_verify = "false"
  gc_stress = "false"
  jvmti_trace_stress = "false"
  jvmti_field_stress = "false"
  jvmti_step_stress = "false"
  jvmti_redefine_stress = "false"
  strace = "false"
  always_clean = "no"
  never_clean = "no"
  have_image = "yes"
  android_root = "/system"
  bisection_search = "no"
  timeout = ""
  suspend_timeout = "500000"
  run_optimizing = "false"
  dump_cfg = "false"
  dump_cfg_path = ""
  # To cause tests to fail fast, limit the file sizes created by dx, dex2oat and
  # ART output to approximately 128MB. This should be more than sufficient
  # for any test while still catching cases of runaway output.
  # Set a hard limit to encourage ART developers to increase the ulimit here if
  # needed to support a test case rather than resetting the limit in the run
  # script for the particular test in question. Adjust this if needed for
  # particular configurations.
  file_ulimit = 128000

  argp, opt_bool = ArgumentParser(), BooleanOptionalAction
  argp.add_argument("--O", action='store_true',
                    help="Run non-debug rather than debug build (off by default).")
  argp.add_argument("--Xcompiler-option", type=str, action='append', default=[],
                    help="Pass an option to the compiler.")
  argp.add_argument("--runtime-option", type=str, action='append', default=[],
                    help="Pass an option to the runtime.")
  argp.add_argument("--debug", action='store_true',
                    help="Wait for the default debugger to attach.")
  argp.add_argument("--debug-agent", type=str,
                    help="Wait for the given debugger agent to attach. Currently "
                         "only supported on host.")
  argp.add_argument("--debug-wrap-agent", action='store_true',
                    help="use libwrapagentproperties and tools/libjdwp-compat.props "
                         "to load the debugger agent specified by --debug-agent.")
  argp.add_argument("--with-agent", type=str, action='append', default=[],
                    help="Run the test with the given agent loaded with -agentpath:")
  argp.add_argument("--debuggable", action='store_true',
                    help="Whether to compile Java code for a debugger.")
  argp.add_argument("--gdb", action='store_true',
                    help="Run under gdb; incompatible with some tests.")
  argp.add_argument("--gdb-dex2oat", action='store_true',
                    help="Run dex2oat under the prebuilt gdb.")
  argp.add_argument("--gdbserver", action='store_true',
                    help="Start gdbserver (defaults to port :5039).")
  argp.add_argument("--gdbserver-port", type=str,
                    help="Start gdbserver with the given COMM (see man gdbserver).")
  argp.add_argument("--gdbserver-bin", type=str,
                    help="Use the given binary as gdbserver.")
  argp.add_argument("--gdb-arg", type=str, action='append', default=[],
                    help="Pass an option to gdb or gdbserver.")
  argp.add_argument("--gdb-dex2oat-args", type=str,
                    help="Pass options separated by ';' to gdb for dex2oat.")
  argp.add_argument("--simpleperf", action='store_true',
                    help="Wraps the dalvikvm invocation in 'simpleperf record "
                         "and dumps stats to stdout.")
  argp.add_argument("--interpreter", action='store_true',
                    help="Enable interpreter only mode (off by default).")
  argp.add_argument("--jit", action='store_true',
                    help="Enable jit (off by default).")
  argp.add_argument("--optimizing", action='store_true',
                    help="Enable optimizing compiler (default).")
  argp.add_argument("--baseline", action='store_true',
                    help="Enable baseline compiler.")
  argp.add_argument("--no-verify", action='store_true',
                    help="Turn off verification (on by default).")
  argp.add_argument("--verify-soft-fail", action='store_true',
                    help="Force soft fail verification (off by default). "
                         "Verification is enabled if neither --no-verify "
                         "nor --verify-soft-fail is specified.")
  argp.add_argument("--no-optimize", action='store_true',
                    help="Turn off optimization (on by default).")
  argp.add_argument("--no-precise", action='store_true',
                    help="Turn off precise GC (on by default).")
  argp.add_argument("--zygote", action='store_true',
                    help="Spawn the process from the Zygote. "
                         "If used, then the other runtime options are ignored.")
  argp.add_argument("--prebuild", action='store_true',
                    help="Run dex2oat on the files before starting test. (default)")
  argp.add_argument("--no-prebuild", action='store_true',
                    help="Do not run dex2oat on the files before starting the test.")
  argp.add_argument("--strip-dex", action='store_true',
                    help="Strip the dex files before starting test.")
  argp.add_argument("--relocate", action='store_true',
                    help="Force the use of relocating in the test, making "
                         "the image and oat files be relocated to a random address before running.")
  argp.add_argument("--no-relocate", action='store_true',
                    help="Force the use of no relocating in the test. (default)")
  argp.add_argument("--image", type=str,
                    help="Run the test using a precompiled boot image. (default)")
  argp.add_argument("--no-image", action='store_true',
                    help="Run the test without a precompiled boot image.")
  argp.add_argument("--host", action='store_true',
                    help="Use the host-mode virtual machine.")
  argp.add_argument("--invoke-with", type=str, action='append', default=[],
                    help="Pass --invoke-with option to runtime.")
  argp.add_argument("--dalvik", action='store_true',
                    help="Use Dalvik (off by default).")
  argp.add_argument("--jvm", action='store_true',
                    help="Use a host-local RI virtual machine.")
  argp.add_argument("--use-java-home", action='store_true',
                    help="Use the JAVA_HOME environment variable to find the java compiler "
                         "and runtime (if applicable) to run the test with.")
  argp.add_argument("--64", dest="is64bit", action='store_true',
                    help="Run the test in 64-bit mode")
  argp.add_argument("--bionic", action='store_true',
                    help="Use the (host, 64-bit only) linux_bionic libc runtime")
  argp.add_argument("--timeout", type=str,
                    help="Test timeout in seconds")
  argp.add_argument("--trace", action='store_true',
                    help="Run with method tracing")
  argp.add_argument("--strace", action='store_true',
                    help="Run with syscall tracing from strace.")
  argp.add_argument("--stream", action='store_true',
                    help="Run method tracing in streaming mode (requires --trace)")
  argp.add_argument("--gcstress", action='store_true',
                    help="Run with gc stress testing")
  argp.add_argument("--gcverify", action='store_true',
                    help="Run with gc verification")
  argp.add_argument("--jvmti-trace-stress", action='store_true',
                    help="Run with jvmti method tracing stress testing")
  argp.add_argument("--jvmti-step-stress", action='store_true',
                    help="Run with jvmti single step stress testing")
  argp.add_argument("--jvmti-redefine-stress", action='store_true',
                    help="Run with jvmti method redefinition stress testing")
  argp.add_argument("--always-clean", action='store_true',
                    help="Delete the test files even if the test fails.")
  argp.add_argument("--never-clean", action='store_true',
                    help="Keep the test files even if the test succeeds.")
  argp.add_argument("--chroot", type=str,
                    help="Run with root directory set to newroot.")
  argp.add_argument("--android-root", type=str,
                    help="The path on target for the android root. (/system by default).")
  argp.add_argument("--android-art-root", type=str,
                    help="The path on target for the ART module root. "
                         "(/apex/com.android.art by default).")
  argp.add_argument("--android-tzdata-root", type=str,
                    help="The path on target for the Android Time Zone Data root. "
                         "(/apex/com.android.tzdata by default).")
  argp.add_argument("--android-i18n-root", type=str,
                    help="The path on target for the i18n module root. "
                         "(/apex/com.android.i18n by default)."),
  argp.add_argument("--dex2oat-swap", action='store_true',
                    help="Use a dex2oat swap file.")
  argp.add_argument("--instruction-set-features", type=str,
                    help="Set instruction-set-features for compilation.")
  argp.add_argument("--quiet", action='store_true',
                    help="Don't print anything except failure messages")
  argp.add_argument("--external-log-tags", action='store_true',
                    help="Deprecated. Use --android-log-tags instead.")
  argp.add_argument("--android-log-tags", type=str,
                    help="Custom logging level for a test run.")
  argp.add_argument("--suspend-timeout", type=str,
                    help="Change thread suspend timeout ms (default 500000).")
  argp.add_argument("--switch-interpreter", action='store_true')
  argp.add_argument("--jvmti-field-stress", action='store_true',
                    help="Run with jvmti method field stress testing")
  argp.add_argument("--vdex", action='store_true',
                    help="Test using vdex as in input to dex2oat. Only works with --prebuild.")
  argp.add_argument("--dm", action='store_true'),
  argp.add_argument("--vdex-filter", type=str)
  argp.add_argument("--random-profile", action='store_true')
  argp.add_argument("--dex2oat-jobs", type=int,
                    help="Number of dex2oat jobs.")
  argp.add_argument("--create-runner", action='store_true',
                    help="Creates a runner script for use with other tools.")
  argp.add_argument("--dev", action='store_true',
                    help="Development mode (dumps to stdout).")
  argp.add_argument("--update", action='store_true',
                    help="Update mode (replaces expected-stdout.txt and expected-stderr.txt).")
  argp.add_argument("--dump-cfg", type=str,
                    help="Dump the CFG to the specified path.")
  argp.add_argument("--bisection-search", action='store_true',
                    help="Perform bisection bug search.")
  argp.add_argument("--temp-path", type=str,
                    help="Location where to execute the tests.")
  argp.add_argument("test_name", nargs="?", default='-', type=str,
                    help="Name of the test to run.")
  argp.add_argument("test_args", nargs="*", default=None,
                    help="Arguments to be passed to the test directly.")

  # Python parser requires the format --key=--value, since without the equals symbol
  # it looks like the required value has been omitted and there is just another flag.
  # For example, '--Xcompiler-option --debuggable' will become '--Xcompiler-option=--debuggable'
  # because otherwise the --Xcompiler-option is missing value and --debuggable is unknown argument.
  argv = list(sys.argv[1:])
  for i, arg in reversed(list(enumerate(argv))):
    if arg in ["--runtime-option", "-Xcompiler-option"]:
      argv[i] += "=" + argv.pop(i + 1)

  # Accept single-dash arguments as if they were double-dash arguments.
  # For example, '-Xcompiler-option' becomes '--Xcompiler-option'
  # because single-dash can be used only with single-letter arguments.
  for i, arg in list(enumerate(argv)):
    if arg.startswith("-") and not arg.startswith("--"):
      argv[i] = "-" + arg
    if arg == "--":
      break

  args = argp.parse_args(argv)

  if True:
    if args.host:
      target_mode = "no"
      DEX_LOCATION = tmp_dir
      run_args += ["--host"]
      os.environ["RUN_MODE"] = "host"
    if args.quiet:
      quiet = "yes"
    if args.use_java_home:
      JAVA_HOME = os.environ.get("JAVA_HOME")
      if JAVA_HOME:
        export("JAVA", f"{JAVA_HOME}/bin/java")
        export("JAVAC", f"{JAVA_HOME}/bin/javac -g")
      else:
        error("Passed --use-java-home without JAVA_HOME variable set!")
        usage = "yes"
    if args.jvm:
      target_mode = "no"
      DEX_LOCATION = tmp_dir
      runtime = "jvm"
      prebuild_mode = "no"
      run_args += ["--jvm"]
    if args.O:
      lib = "libart.so"
      testlib = "arttest"
      run_args += ["-O"]
    if args.dalvik:
      lib = "libdvm.so"
      runtime = "dalvik"
    if args.no_image:
      have_image = "no"
    if args.relocate:
      relocate = "yes"
    if args.no_relocate:
      relocate = "no"
    if args.prebuild:
      run_args += ["--prebuild"]
      prebuild_mode = "yes"
    if args.strip_dex:
      run_args += ["--strip-dex"]
    if args.debuggable:
      run_args += ["-Xcompiler-option --debuggable"]
      debuggable = "yes"
    if args.no_prebuild:
      run_args += ["--no-prebuild"]
      prebuild_mode = "no"
    if args.gcverify:
      basic_verify = "true"
      gc_verify = "true"
    if args.gcstress:
      basic_verify = "true"
      gc_stress = "true"
    if args.jvmti_step_stress:
      jvmti_step_stress = "true"
      os.environ["JVMTI_STEP_STRESS"] = "true"
    if args.jvmti_redefine_stress:
      jvmti_redefine_stress = "true"
      os.environ["JVMTI_REDEFINE_STRESS"] = "true"
    if args.jvmti_field_stress:
      jvmti_field_stress = "true"
      os.environ["JVMTI_FIELD_STRESS"] = "true"
    if args.jvmti_trace_stress:
      jvmti_trace_stress = "true"
      os.environ["JVMTI_TRACE_STRESS"] = "true"
    if args.suspend_timeout:
      suspend_timeout = args.suspend_timeout
    if args.image:
      image = args.image
      run_args += [f'--image "{image}"']
    if args.Xcompiler_option:
      run_args += [f'-Xcompiler-option "{option}"' for option in args.Xcompiler_option]
    if args.runtime_option:
      run_args += [f'--runtime-option "{option}"' for option in args.runtime_option]
    if args.gdb_arg:
      run_args += [f'--gdb-arg "{gdb_arg}"' for gdb_arg in args.gdb_arg]
    if args.gdb_dex2oat_args:
      gdb_dex2oat_args = args.gdb_dex2oat_args
      run_args += [f'--gdb-dex2oat-args="{gdb_dex2oat_args}"']
    if args.debug:
      run_args += ["--debug"]
    if args.debug_wrap_agent:
      run_args += ["--debug-wrap-agent"]
    if args.with_agent:
      run_args += [f'--with-agent "{arg}"' for arg in args.with_agent]
    if args.debug_agent:
      run_args += [f'--debug-agent "{args.debug_agent}"']
    if args.dump_cfg:
      dump_cfg = "true"
      dump_cfg_path = args.dump_cfg
    if args.gdb:
      run_args += ["--gdb"]
      dev_mode = "yes"
    if args.gdb_dex2oat:
      run_args += ["--gdb-dex2oat"]
      dev_mode = "yes"
    if args.gdbserver_bin:
      run_args += [f'--gdbserver-bin "{args.gdbserver_bin}"']
    if args.gdbserver_port:
      run_args += [f'--gdbserver-port "{args.gdbserver_port}"']
    if args.gdbserver:
      run_args += ["--gdbserver"]
      dev_mode = "yes"
    if args.strace:
      strace = "yes"
      run_args += [
          f'--invoke-with=strace --invoke-with=-o --invoke-with="{tmp_dir}/{strace_output}"'
      ]
      timeout = timeout or "1800"
    if args.zygote:
      run_args += ["--zygote"]
    if args.interpreter:
      run_args += ["--interpreter"]
    if args.switch_interpreter:
      run_args += ["--switch-interpreter"]
    if args.jit:
      run_args += ["--jit"]
    if args.baseline:
      run_args += ["--baseline"]
    if args.optimizing:
      run_optimizing = "true"
    if args.no_verify:
      run_args += ["--no-verify"]
    if args.verify_soft_fail:
      run_args += ["--verify-soft-fail"]
      os.environ["VERIFY_SOFT_FAIL"] = "true"
    if args.no_optimize:
      run_args += ["--no-optimize"]
    if args.no_precise:
      run_args += ["--no-precise"]
    if args.android_log_tags:
      run_args += [f"--android-log-tags {args.android_log_tags}"]
    if args.external_log_tags:
      run_args += ["--external-log-tags"]
    if args.invoke_with:
      run_args += [f'--invoke-with "{what}"' for what in args.invoke_with]
    if args.create_runner:
      run_args += ["--create-runner --dry-run"]
      dev_mode = "yes"
      never_clean = "yes"
      create_runner = "yes"
    if args.dev:
      dev_mode = "yes"
    if args.chroot:
      chroot = args.chroot
      run_args += [f'--chroot "{args.chroot}"']
    if args.simpleperf:
      run_args += ["--simpleperf"]
    if args.android_root:
      android_root = args.android_root
      run_args += [f'--android-root "{args.android_root}"']
    if args.android_art_root:
      run_args += [f'--android-art-root "{args.android_art_root}"']
    if args.android_tzdata_root:
      run_args += [f'--android-tzdata-root "{args.android_tzdata_root}"']
    if args.update:
      update_mode = "yes"
    if args.is64bit:
      run_args += ["--64"]
      suffix64 = "64"
    if args.bionic:
      # soong linux_bionic builds are 64bit only.
      run_args += ["--bionic --host --64"]
      suffix64 = "64"
      target_mode = "no"
      DEX_LOCATION = tmp_dir
      host_lib_root = f"{OUT_DIR}/soong/host/linux_bionic-x86"
    if args.timeout:
      timeout = args.timeout
    if args.trace:
      trace = "true"
    if args.stream:
      trace_stream = "true"
    if args.always_clean:
      always_clean = "yes"
    if args.never_clean:
      never_clean = "yes"
    if args.dex2oat_swap:
      run_args += ["--dex2oat-swap"]
    if args.instruction_set_features:
      run_args += [f'--instruction-set-features "{args.instruction_set_features}"']
    if args.bisection_search:
      bisection_search = "yes"
    if args.vdex:
      run_args += ["--vdex"]
    if args.dm:
      run_args += ["--dm"]
    if args.vdex_filter:
      run_args += [f'--vdex-filter "{args.vdex_filter}"']
    if args.random_profile:
      run_args += ["--random-profile"]
    if args.dex2oat_jobs:
      run_args += [f'-Xcompiler-option "-j{str(args.dex2oat_jobs)}"']

  export("DEX_LOCATION", DEX_LOCATION)

# The DEX_LOCATION with the chroot prefix, if any.
  chroot_dex_location = f"{chroot}{DEX_LOCATION}"

  # tmp_dir may be relative, resolve.
  os.chdir(oldwd)
  tmp_dir = os.path.realpath(tmp_dir)
  os.chdir(progdir)
  if not tmp_dir:
    error(f"Failed to resolve {tmp_dir}")
    sys.exit(1)
  os.makedirs(tmp_dir, exist_ok=True)

  # Add thread suspend timeout flag
  if runtime != "jvm":
    run_args += [
        f'--runtime-option "-XX:ThreadSuspendTimeout={suspend_timeout}"'
    ]

  if basic_verify == "true":
    # Set HspaceCompactForOOMMinIntervalMs to zero to run hspace compaction for OOM more frequently in tests.
    run_args += [
        "--runtime-option -Xgc:preverify --runtime-option -Xgc:postverify "
        "--runtime-option -XX:HspaceCompactForOOMMinIntervalMs=0"
    ]
  if gc_verify == "true":
    run_args += [
        "--runtime-option -Xgc:preverify_rosalloc --runtime-option "
        "-Xgc:postverify_rosalloc"
    ]
  if gc_stress == "true":
    run_args += [
        "--gc-stress --runtime-option -Xgc:gcstress --runtime-option -Xms2m "
        "--runtime-option -Xmx16m"
    ]
  if jvmti_redefine_stress == "true":
    run_args += ["--no-app-image --jvmti-redefine-stress"]
  if jvmti_step_stress == "true":
    run_args += ["--no-app-image --jvmti-step-stress"]
  if jvmti_field_stress == "true":
    run_args += ["--no-app-image --jvmti-field-stress"]
  if jvmti_trace_stress == "true":
    run_args += ["--no-app-image --jvmti-trace-stress"]
  if trace == "true":
    run_args += [
        "--runtime-option -Xmethod-trace --runtime-option "
        "-Xmethod-trace-file-size:2000000"
    ]
    if trace_stream == "true":
      # Streaming mode uses the file size as the buffer size. So output gets really large. Drop
      # the ability to analyze the file and just write to /dev/null.
      run_args += ["--runtime-option -Xmethod-trace-file:/dev/null"]
      # Enable streaming mode.
      run_args += ["--runtime-option -Xmethod-trace-stream"]
    else:
      run_args += [
          f'--runtime-option "-Xmethod-trace-file:{DEX_LOCATION}/trace.bin"'
      ]
  elif trace_stream == "true":
    error("Cannot use --stream without --trace.")
    sys.exit(1)
  if timeout:
    run_args += [f'--timeout "{timeout}"']

# Most interesting target architecture variables are Makefile variables, not environment variables.
# Try to map the suffix64 flag and what we find in {ANDROID_PRODUCT_OUT}/data/art-test to an architecture name.

  def guess_target_arch_name():
    return get_target_arch(suffix64 == "64")

  def guess_host_arch_name():
    if suffix64 == "64":
      return "x86_64"
    else:
      return "x86"

  if target_mode == "no":
    if runtime == "jvm":
      if prebuild_mode == "yes":
        error("--prebuild with --jvm is unsupported")
        sys.exit(1)
    else:
      # ART/Dalvik host mode.
      if chroot:
        error("--chroot with --host is unsupported")
        sys.exit(1)

  if runtime != "jvm":
    run_args += [f'--lib "{lib}"']

  ANDROID_PRODUCT_OUT = os.environ.get("ANDROID_PRODUCT_OUT")
  if runtime == "dalvik":
    if target_mode == "no":
      framework = f"{ANDROID_PRODUCT_OUT}/system/framework"
      bpath = f"{framework}/core-icu4j.jar:{framework}/core-libart.jar:{framework}/core-oj.jar:{framework}/conscrypt.jar:{framework}/okhttp.jar:{framework}/bouncycastle.jar:{framework}/ext.jar"
      run_args += [f'--boot --runtime-option "-Xbootclasspath:{bpath}"']
    else:
      pass  # defaults to using target BOOTCLASSPATH
  elif runtime == "art":
    if target_mode == "no":
      host_arch_name = guess_host_arch_name()
      run_args += [
          f'--boot "{ANDROID_HOST_OUT}/apex/art_boot_images/javalib/boot.art"'
      ]
      run_args += [
          f'--runtime-option "-Djava.library.path={host_lib_root}/lib{suffix64}:{host_lib_root}/nativetest{suffix64}"'
      ]
    else:
      target_arch_name = guess_target_arch_name()
      # Note that libarttest(d).so and other test libraries that depend on ART
      # internal libraries must not be in this path for JNI libraries - they
      # need to be loaded through LD_LIBRARY_PATH and
      # NATIVELOADER_DEFAULT_NAMESPACE_LIBS instead.
      run_args += [
          f'--runtime-option "-Djava.library.path=/data/nativetest{suffix64}/art/{target_arch_name}"'
      ]
      run_args += ['--boot "/system/framework/art_boot_images/boot.art"']
    if relocate == "yes":
      run_args += ["--relocate"]
    else:
      run_args += ["--no-relocate"]
  elif runtime == "jvm":
    # TODO: Detect whether the host is 32-bit or 64-bit.
    run_args += [
        f'--runtime-option "-Djava.library.path={ANDROID_HOST_OUT}/lib64:{ANDROID_HOST_OUT}/nativetest64"'
    ]

  if have_image == "no":
    if runtime != "art":
      error("--no-image is only supported on the art runtime")
      sys.exit(1)
    run_args += ["--no-image"]

  if create_runner == "yes" and target_mode == "yes":
    error("--create-runner does not function for non --host tests")
    usage = "yes"

  if dev_mode == "yes" and update_mode == "yes":
    error("--dev and --update are mutually exclusive")
    usage = "yes"

  if dev_mode == "yes" and quiet == "yes":
    error("--dev and --quiet are mutually exclusive")
    usage = "yes"

  if bisection_search == "yes" and prebuild_mode == "yes":
    error("--bisection-search and --prebuild are mutually exclusive")
    usage = "yes"

# TODO: Chroot-based bisection search is not supported yet (see below); implement it.
  if bisection_search == "yes" and chroot:
    error("--chroot with --bisection-search is unsupported")
    sys.exit(1)

  if args.test_name == "-":
    test_dir = os.path.basename(oldwd)
  else:
    test_dir = args.test_name

  if not os.path.isdir(test_dir):
    td2 = glob.glob(f"{test_dir}-*")
    if len(td2) == 1 and os.path.isdir(td2[0]):
      test_dir = td2[0]
    else:
      error(f"{test_dir}: no such test directory")
      usage = "yes"

  os.chdir(test_dir)
  test_dir = os.getcwd()

  TEST_NAME = os.path.basename(test_dir)
  export("TEST_NAME", TEST_NAME)

  # Tests named '<number>-checker-*' will also have their CFGs verified with
  # Checker when compiled with Optimizing on host.
  # Additionally, if the user specifies that the CFG must be dumped, it will
  # run the checker for any type of test to generate the CFG.
  if re.match("[0-9]+-checker-", TEST_NAME) or dump_cfg == "true":
    if runtime == "art" and run_optimizing == "true":
      # In no-prebuild or no-image mode, the compiler only quickens so disable the checker.
      if prebuild_mode == "yes":
        run_checker = "yes"

        if target_mode == "no":
          cfg_output_dir = tmp_dir
          checker_args = f"--arch={host_arch_name.upper()}"
        else:
          cfg_output_dir = DEX_LOCATION
          checker_args = f"--arch={target_arch_name.upper()}"

        if debuggable == "yes":
          checker_args += " --debuggable"

        run_args += [
            f'-Xcompiler-option "--dump-cfg={cfg_output_dir}/{cfg_output}" -Xcompiler-option -j1'
        ]
        checker_args = f"{checker_args} --print-cfg"

  run_args += [f'--testlib "{testlib}"']

  resource.setrlimit(resource.RLIMIT_FSIZE, (file_ulimit * 1024, resource.RLIM_INFINITY))

  # Extract run-test data from the zip file.
  shutil.rmtree(tmp_dir)
  os.makedirs(f"{tmp_dir}/.unzipped")
  os.chdir(tmp_dir)
  m = re.match("[0-9]*([0-9][0-9])-.*", TEST_NAME)
  assert m, "Can not find test number in " + TEST_NAME
  SHARD = "HiddenApi" if "hiddenapi" in TEST_NAME else m.group(1)
  if target_mode == "yes":
    zip_file = f"{ANDROID_HOST_OUT}/etc/art/art-run-test-target-data-shard{SHARD}.zip"
    zip_entry = f"target/{TEST_NAME}/"
  elif runtime == "jvm":
    zip_file = f"{ANDROID_HOST_OUT}/etc/art/art-run-test-jvm-data-shard{SHARD}.zip"
    zip_entry = f"jvm/{TEST_NAME}/"
  else:
    zip_file = f"{ANDROID_HOST_OUT}/etc/art/art-run-test-host-data-shard{SHARD}.zip"
    zip_entry = f"host/{TEST_NAME}/"
  zip = ZipFile(zip_file, "r")
  zip_entries = [e for e in zip.namelist() if e.startswith(zip_entry)]
  zip.extractall(Path(tmp_dir) / ".unzipped", members=zip_entries)
  for entry in (Path(tmp_dir) / ".unzipped" / zip_entry).iterdir():
    entry.rename(Path(tmp_dir) / entry.name)

  def clean_up(passed: bool):
    if always_clean == "yes" or (passed and never_clean == "no"):
      os.chdir(oldwd)
      shutil.rmtree(tmp_dir)
      if target_mode == "yes":
        if ON_VM:
          run(f"{SSH_CMD} \"rm -rf {chroot_dex_location}\"")
        else:
          run(f"adb shell rm -rf {chroot_dex_location}")
      print(f"{TEST_NAME} files deleted from host" +
            (" and from target" if target_mode == "yes" else ""))
    else:
      print(f"{TEST_NAME} files left in {tmp_dir} on host" +
            (f" and in {chroot_dex_location} on target" if target_mode == "yes" else ""))
    atexit.unregister(clean_up)
  # TODO: Run this in global try-finally once the script is more refactored.
  atexit.register(clean_up, passed=False)

  ctx = RunTestContext(Path(tmp_dir), target_mode == "yes", chroot, DEX_LOCATION, TEST_NAME)
  td_info = f"{test_dir}/{info}"
  for td_file in [td_info, ctx.expected_stdout, ctx.expected_stderr]:
    assert os.access(td_file, os.R_OK)

  # Create runner (bash script that executes the whole test)
  def create_runner_script() -> Path:
    parsed_args = default_run_module.parse_args(shlex.split(" ".join(run_args + args.test_args)))
    parsed_args.stdout_file = os.path.join(DEX_LOCATION, test_stdout)
    parsed_args.stderr_file = os.path.join(DEX_LOCATION, test_stderr)

    ctx.run(f"cd {DEX_LOCATION}")
    if target_mode != "yes":
      # Make "out" directory accessible from test directory.
      ctx.run(f"ln -s -f -t {DEX_LOCATION} {ANDROID_BUILD_TOP}/out")
    # Clear the stdout/stderr files (create empty files).
    ctx.run(f"echo -n > {test_stdout} && echo -n > {test_stderr}")

    script = Path(tmp_dir) / "run.py"
    if script.exists():
      module = SourceFileLoader("run_" + TEST_NAME, str(script)).load_module()
      module.run(ctx, parsed_args)
    else:
      default_run_module.default_run(ctx, parsed_args)

    runner = Path(tmp_dir) / "run.sh"
    runner.write_text("\n".join(ctx.runner))
    runner.chmod(0o777)
    return runner

  def do_dump_cfg():
    assert run_optimizing == "true", ("The CFG can be dumped only in"
                                      " optimizing mode")
    if target_mode == "yes":
      if ON_VM:
        run(f'{SCP_CMD} "{SSH_USER}@${SSH_HOST}:{CHROOT}/{cfg_output_dir}/'
            f'{cfg_output} {dump_cfg_path}"')
      else:
        run(f"adb pull {chroot}/{cfg_output_dir}/{cfg_output} {dump_cfg_path}")
    else:
      run(f"cp {cfg_output_dir}/{cfg_output} {dump_cfg_path}")

  # Test might not execute anything but we still expect the output files to exist.
  Path(test_stdout).touch()
  Path(test_stderr).touch()

  export("TEST_RUNTIME", runtime)

  print(f"{test_dir}: Create runner script...")
  runner = create_runner_script()

  print(f"{test_dir}: Run...")
  if target_mode == "yes":
    # Prepare the on-device test directory
    if ON_VM:
      run(f"{SSH_CMD} 'rm -rf {chroot_dex_location} && mkdir -p {chroot_dex_location}'")
    else:
      run("adb root")
      run("adb wait-for-device")
      run(f"adb shell 'rm -rf {chroot_dex_location} && mkdir -p {chroot_dex_location}'")
    push_files = [Path(runner.name)]
    push_files += list(Path(".").glob(f"{TEST_NAME}*.jar"))
    push_files += list(Path(".").glob(f"expected-*.txt"))
    push_files += [p for p in [Path("profile"), Path("res")] if p.exists()]
    push_files = " ".join(map(str, push_files))
    if ON_VM:
      run(f"{SCP_CMD} {push_files} {SSH_USER}@{SSH_HOST}:{chroot_dex_location}")
    else:
      run("adb push {} {}".format(push_files, chroot_dex_location))

    try:
      if ON_VM:
        run(f"{SSH_CMD} {CHROOT_CMD} bash {DEX_LOCATION}/run.sh",
            fail_message=f"Runner {chroot_dex_location}/run.sh failed")
      else:
        chroot_prefix = f"chroot {chroot}" if chroot else ""
        run(f"adb shell {chroot_prefix} sh {DEX_LOCATION}/run.sh",
            fail_message=f"Runner {chroot_dex_location}/run.sh failed")
    finally:
      # Copy the generated CFG to the specified path.
      if dump_cfg == "true":
        do_dump_cfg()

    # Copy the on-device stdout/stderr to host.
    pull_files = [test_stdout, test_stderr, "expected-stdout.txt", "expected-stderr.txt"]
    if ON_VM:
      srcs = " ".join(f"{SSH_USER}@{SSH_HOST}:{chroot_dex_location}/{f}" for f in pull_files)
      run(f"{SCP_CMD} {srcs} .")
    else:
      run("adb pull {} .".format(" ".join(f"{chroot_dex_location}/{f}" for f in pull_files)))
  else:
    run(str(runner), fail_message=f"Runner {str(runner)} failed")

  # NB: There is no exit code or return value.
  # Failing tests just raise python exception.
  os.chdir(tmp_dir)
  if update_mode == "yes":
    for src, dst in [(test_stdout, os.path.join(test_dir, ctx.expected_stdout.name)),
                     (test_stderr, os.path.join(test_dir, ctx.expected_stderr.name))]:
      if "[DO_NOT_UPDATE]" not in open(dst).readline():
        copyfile(src, dst)

  print("#################### info")
  run(f'cat "{td_info}" | sed "s/^/# /g"')
  print("#################### stdout diff")
  proc_out = run(f'diff --strip-trailing-cr -u '
                 f'"{ctx.expected_stdout}" "{test_stdout}"', check=False)
  print("#################### stderr diff")
  proc_err = run(f'diff --strip-trailing-cr -u '
                 f'"{ctx.expected_stderr}" "{test_stderr}"', check=False)
  if strace == "yes":
    print("#################### strace output (trimmed to 3000 lines)")
    # Some tests do not run dalvikvm, in which case the trace does not exist.
    run(f'tail -n 3000 "{tmp_dir}/{strace_output}"', check=False)
  SANITIZE_HOST = os.environ.get("SANITIZE_HOST")
  if target_mode == "no" and SANITIZE_HOST == "address":
    # Run the stack script to symbolize any ASAN aborts on the host for SANITIZE_HOST. The
    # tools used by the given ABI work for both x86 and x86-64.
    print("#################### symbolizer (trimmed to 3000 lines)")
    run(f'''echo "ABI: 'x86_64'" | cat - "{test_stdout}" "{test_stderr}"'''
        f"""| {ANDROID_BUILD_TOP}/development/scripts/stack | tail -n 3000""")
  print("####################", flush=True)

  try:
    if proc_out.returncode != 0 or proc_err.returncode != 0:
      kind = ((["stdout"] if proc_out.returncode != 0 else []) +
              (["stderr"] if proc_err.returncode != 0 else []))
      fail("{} did not match the expected file".format(" and ".join(kind)))

    if run_checker == "yes":
      if target_mode == "yes":
        if ON_VM:
          run(f'{SCP_CMD} "{SSH_USER}@{SSH_HOST}:{CHROOT}/{cfg_output_dir}/'
              f'{cfg_output}" "{tmp_dir}"')
        else:
          run(f'adb pull "{chroot}/{cfg_output_dir}/{cfg_output}"')
      run(f'"{checker}" -q {checker_args} "{cfg_output}" "{tmp_dir}"',
          fail_message="CFG checker failed")
  finally:
    # Copy the generated CFG to the specified path.
    if dump_cfg == "true":
      do_dump_cfg()

  clean_up(passed=True)
  print(f"{COLOR_GREEN}{test_dir}: PASSED{COLOR_NORMAL}")
